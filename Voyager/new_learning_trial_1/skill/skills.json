{"mineOneWoodLog": {"code": "async function mineOneWoodLog(bot) {\n  // Step 1: Explore until we find a wood log\n  const logTypes = [\"oak_log\", \"birch_log\", \"spruce_log\", \"jungle_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n  let foundLog = null;\n  // Choose a random direction for exploration (one of the four cardinal directions plus up/down)\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n  const randomDir = directions[Math.floor(Math.random() * directions.length)];\n  bot.chat(\"Exploring to find a wood log...\");\n  foundLog = await exploreUntil(bot, randomDir, 60, () => {\n    for (const logName of logTypes) {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName[logName]?.id,\n        maxDistance: 32\n      });\n      if (block) return block;\n    }\n    return null;\n  });\n  if (!foundLog) {\n    bot.chat(\"Could not find a wood log within exploration time.\");\n    return;\n  }\n  // Step 2: Mine 1 log\n  const logName = mcData.blocks[foundLog.type].name;\n  bot.chat(`Found ${logName}, mining...`);\n  await mineBlock(bot, logName, 1);\n  // Step 3: Verify we have a log\n  const logItem = mcData.itemsByName[logName];\n  if (bot.inventory.count(logItem.id) < 1) {\n    bot.chat(\"Failed to mine a wood log.\");\n  } else {\n    bot.chat(\"Successfully mined 1 wood log.\");\n  }\n}", "description": "async function mineOneWoodLog(bot) {\n    // The function is about mining one wood log from various tree types. First, explore the environment in a random direction until finding a wood log block. Once a wood log block is found, mine exactly one wood log block. Finally, verify that the wood log has been successfully collected into the inventory.\n}"}, "mineFourOakLog": {"code": "async function mineFourOakLog(bot) {\n  const requiredCount = 4;\n  const currentCount = bot.inventory.count(mcData.itemsByName.oak_log.id);\n  bot.chat(`I have ${currentCount} oak logs, need ${requiredCount - currentCount} more.`);\n  if (currentCount >= requiredCount) {\n    bot.chat(\"Already have enough oak logs.\");\n    return;\n  }\n  const needed = requiredCount - currentCount;\n  // Explore until we find enough oak_log blocks\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n  const randomDir = directions[Math.floor(Math.random() * directions.length)];\n  const foundBlocks = await exploreUntil(bot, randomDir, 60, () => {\n    const blocks = bot.findBlocks({\n      matching: mcData.blocksByName.oak_log.id,\n      maxDistance: 32,\n      count: needed\n    });\n    if (blocks.length >= needed) {\n      return blocks;\n    }\n    return null;\n  });\n  if (!foundBlocks) {\n    bot.chat(\"Could not find enough oak logs within exploration time.\");\n    return;\n  }\n  bot.chat(`Found enough oak logs, mining ${needed}...`);\n  await mineBlock(bot, \"oak_log\", needed);\n  const finalCount = bot.inventory.count(mcData.itemsByName.oak_log.id);\n  if (finalCount >= requiredCount) {\n    bot.chat(`Successfully mined ${needed} oak logs. Now have ${finalCount}.`);\n  } else {\n    bot.chat(`Failed to mine enough oak logs. Only have ${finalCount}.`);\n  }\n}", "description": "async function mineFourOakLog(bot) {\n    // The function is about mining oak logs until having at least four in total. First check the current number of oak logs in the inventory. If there are already enough, the function ends. Otherwise, calculate how many more logs are needed. Then explore the environment in a random direction to find the required number of oak log blocks. If enough logs are found, mine them. Finally, verify the final count of oak logs in the inventory.\n}"}, "craftCraftingTable": {"code": "async function craftCraftingTable(bot) {\n  // Check if we already have a crafting table\n  const craftingTableItem = mcData.itemsByName.crafting_table;\n  if (bot.inventory.count(craftingTableItem.id) > 0) {\n    bot.chat(\"Already have a crafting table.\");\n    return;\n  }\n\n  // Check for oak_planks\n  const oakPlanksItem = mcData.itemsByName.oak_planks;\n  let oakPlanksCount = bot.inventory.count(oakPlanksItem.id);\n  if (oakPlanksCount < 4) {\n    // Need to craft oak_planks from oak_log\n    const oakLogItem = mcData.itemsByName.oak_log;\n    const oakLogCount = bot.inventory.count(oakLogItem.id);\n    if (oakLogCount < 1) {\n      bot.chat(\"No oak logs to craft planks.\");\n      // We need to collect oak logs first, but the task only asks to craft a crafting table.\n      // Since we have 4 oak_log in inventory, this should not happen.\n      // However, for robustness, we could mine more logs, but the task doesn't require it.\n      // We'll assume we have logs.\n      return;\n    }\n    bot.chat(\"Crafting oak planks...\");\n    // Craft 4 oak_planks from 1 oak_log using the personal crafting grid.\n    // The craftItem function requires a crafting table, but we don't have one yet.\n    // We need to use bot.craft directly for the 2x2 grid.\n    const recipe = bot.recipesFor(oakPlanksItem.id, null, 1, null)[0];\n    if (!recipe) {\n      bot.chat(\"No recipe for oak planks found.\");\n      return;\n    }\n    try {\n      await bot.craft(recipe, 1, null);\n      bot.chat(\"Crafted 4 oak planks.\");\n    } catch (err) {\n      bot.chat(`Failed to craft oak planks: ${err.message}`);\n      return;\n    }\n    // Update count\n    oakPlanksCount = bot.inventory.count(oakPlanksItem.id);\n  }\n\n  // Now craft crafting table\n  if (oakPlanksCount >= 4) {\n    bot.chat(\"Crafting a crafting table...\");\n    const recipe = bot.recipesFor(craftingTableItem.id, null, 1, null)[0];\n    if (!recipe) {\n      bot.chat(\"No recipe for crafting table found.\");\n      return;\n    }\n    try {\n      await bot.craft(recipe, 1, null);\n      bot.chat(\"Crafted a crafting table.\");\n    } catch (err) {\n      bot.chat(`Failed to craft crafting table: ${err.message}`);\n      return;\n    }\n  } else {\n    bot.chat(\"Not enough oak planks to craft a crafting table.\");\n  }\n\n  // Final check\n  if (bot.inventory.count(craftingTableItem.id) > 0) {\n    bot.chat(\"Successfully crafted a crafting table.\");\n  } else {\n    bot.chat(\"Failed to craft a crafting table.\");\n  }\n}", "description": "async function craftCraftingTable(bot) {\n    // The function is about crafting a crafting table using oak planks. First check if a crafting table is already in the inventory. If not, check if there are at least 4 oak planks available. If there are insufficient oak planks, craft them from oak logs using the personal crafting grid. Then, if enough oak planks are present, craft a crafting table using the personal crafting grid. Finally, verify whether the crafting table has been successfully crafted.\n}"}, "craftWoodenPickaxe": {"code": "async function craftWoodenPickaxe(bot) {\n  // Check if we already have a wooden pickaxe\n  const woodenPickaxeItem = mcData.itemsByName.wooden_pickaxe;\n  if (bot.inventory.count(woodenPickaxeItem.id) > 0) {\n    bot.chat(\"Already have a wooden pickaxe.\");\n    return;\n  }\n\n  // Place crafting table if not already placed nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    // Find a suitable position near the bot to place the crafting table\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Update the crafting table block\n    craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTableBlock) {\n      bot.chat(\"Failed to place crafting table.\");\n      return;\n    }\n  }\n\n  // Ensure we have enough oak_planks (need at least 5)\n  const oakPlanksItem = mcData.itemsByName.oak_planks;\n  let oakPlanksCount = bot.inventory.count(oakPlanksItem.id);\n  if (oakPlanksCount < 5) {\n    bot.chat(\"Crafting oak planks...\");\n    // We have oak_log, craft planks from them\n    const oakLogItem = mcData.itemsByName.oak_log;\n    const oakLogCount = bot.inventory.count(oakLogItem.id);\n    // Each log gives 4 planks, we need at least 5 planks, so we need 2 logs (8 planks)\n    const logsNeeded = Math.ceil((5 - oakPlanksCount) / 4);\n    if (oakLogCount < logsNeeded) {\n      bot.chat(`Not enough oak logs. Need ${logsNeeded}, have ${oakLogCount}.`);\n      // We could mine more logs, but the task assumes we have enough. For robustness, we could explore and mine.\n      // However, the inventory shows 3 oak_log, which is enough for 12 planks.\n      // So we should be fine.\n      return;\n    }\n    // Craft planks using the crafting table\n    // craftItem function crafts the item using the crafting table.\n    // We need to craft planks multiple times? Actually, craftItem can craft multiple items at once?\n    // The craftItem function uses bot.craft with the recipe and count. The count is the number of times to craft the recipe.\n    // For oak_planks, the recipe yields 4 planks per log. So if we want 8 planks, we need to craft 2 times.\n    // We'll craft logsNeeded times.\n    try {\n      await craftItem(bot, \"oak_planks\", logsNeeded);\n    } catch (err) {\n      bot.chat(`Failed to craft oak planks: ${err.message}`);\n      return;\n    }\n    // Update count\n    oakPlanksCount = bot.inventory.count(oakPlanksItem.id);\n    bot.chat(`Now have ${oakPlanksCount} oak planks.`);\n  }\n\n  // Ensure we have sticks (need at least 2)\n  const stickItem = mcData.itemsByName.stick;\n  let stickCount = bot.inventory.count(stickItem.id);\n  if (stickCount < 2) {\n    bot.chat(\"Crafting sticks...\");\n    // Each craft of sticks requires 2 planks and yields 4 sticks.\n    // We need at least 2 sticks, so craft once.\n    // Check if we have enough planks (need 2 planks)\n    if (oakPlanksCount < 2) {\n      bot.chat(\"Not enough planks to craft sticks.\");\n      return;\n    }\n    try {\n      await craftItem(bot, \"stick\", 1);\n    } catch (err) {\n      bot.chat(`Failed to craft sticks: ${err.message}`);\n      return;\n    }\n    stickCount = bot.inventory.count(stickItem.id);\n    bot.chat(`Now have ${stickCount} sticks.`);\n  }\n\n  // Craft wooden pickaxe\n  bot.chat(\"Crafting wooden pickaxe...\");\n  try {\n    await craftItem(bot, \"wooden_pickaxe\", 1);\n  } catch (err) {\n    bot.chat(`Failed to craft wooden pickaxe: ${err.message}`);\n    return;\n  }\n\n  // Final check\n  if (bot.inventory.count(woodenPickaxeItem.id) > 0) {\n    bot.chat(\"Successfully crafted a wooden pickaxe.\");\n  } else {\n    bot.chat(\"Failed to craft a wooden pickaxe.\");\n  }\n}", "description": "async function craftWoodenPickaxe(bot) {\n    // The function is about crafting a wooden pickaxe using a crafting table. First check if a wooden pickaxe is already in the inventory. If not, ensure a crafting table is placed nearby. Then ensure there are enough oak planks and sticks by crafting them from oak logs if necessary. Finally, craft the wooden pickaxe using the required materials.\n}"}, "mineFourCobblestone": {"code": "async function mineFourCobblestone(bot) {\n  const cobblestoneItem = mcData.itemsByName.cobblestone;\n  const requiredCount = 4;\n  // Step 1: Check current cobblestone count\n  let currentCount = bot.inventory.count(cobblestoneItem.id);\n  if (currentCount >= requiredCount) {\n    bot.chat(\"Already have at least 4 cobblestone.\");\n    return;\n  }\n  // Step 2: Ensure we have a pickaxe\n  const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && bot.inventory.count(item.id) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No pickaxe found. Need a pickaxe to mine stone.\");\n    // Could craft one, but task assumes we have one. We'll just return.\n    return;\n  }\n  // Step 3: Explore until find stone\n  bot.chat(\"Exploring to find stone...\");\n  const stoneBlocks = await exploreUntil(bot, new Vec3(0, -1, 0), 60, () => {\n    const blocks = bot.findBlocks({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32,\n      count: requiredCount\n    });\n    if (blocks.length >= requiredCount) {\n      return blocks;\n    }\n    return null;\n  });\n  if (!stoneBlocks) {\n    bot.chat(\"Could not find enough stone within exploration time.\");\n    return;\n  }\n  // Step 4: Mine stone\n  bot.chat(`Found stone, mining ${requiredCount}...`);\n  await mineBlock(bot, \"stone\", requiredCount);\n  // Step 5: Verify\n  currentCount = bot.inventory.count(cobblestoneItem.id);\n  if (currentCount >= requiredCount) {\n    bot.chat(`Successfully mined ${requiredCount} cobblestone. Now have ${currentCount}.`);\n  } else {\n    bot.chat(`Failed to mine enough cobblestone. Only have ${currentCount}.`);\n  }\n}", "description": "async function mineFourCobblestone(bot) {\n    // The function is about mining 4 cobblestones using any available pickaxe. First check if at least 4 cobblestones are already in the inventory. If not, ensure a pickaxe is available. Then explore the environment until finding enough stone blocks. Once found, mine a total of 4 cobblestone blocks. Finally, verify the inventory to confirm the cobblestone count.\n}"}, "craftStonePickaxe": {"code": "async function craftStonePickaxe(bot) {\n  // Check if we already have a stone pickaxe\n  const stonePickaxeItem = mcData.itemsByName.stone_pickaxe;\n  if (bot.inventory.count(stonePickaxeItem.id) > 0) {\n    bot.chat(\"Already have a stone pickaxe.\");\n    return;\n  }\n\n  // Check required materials: 3 cobblestone and 2 sticks\n  const cobblestoneItem = mcData.itemsByName.cobblestone;\n  const stickItem = mcData.itemsByName.stick;\n  const cobblestoneCount = bot.inventory.count(cobblestoneItem.id);\n  const stickCount = bot.inventory.count(stickItem.id);\n  if (cobblestoneCount < 3) {\n    bot.chat(`Need 3 cobblestone, but only have ${cobblestoneCount}.`);\n    // We could mine more cobblestone, but the task assumes we have enough.\n    // Since we have 4 cobblestone, this should not happen.\n    return;\n  }\n  if (stickCount < 2) {\n    bot.chat(`Need 2 sticks, but only have ${stickCount}.`);\n    // We have 2 sticks, so this should not happen.\n    return;\n  }\n\n  // Ensure a crafting table block is placed nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    // Find a suitable position near the bot to place the crafting table\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Update the crafting table block\n    craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTableBlock) {\n      bot.chat(\"Failed to place crafting table.\");\n      return;\n    }\n  }\n\n  // Craft stone pickaxe\n  bot.chat(\"Crafting stone pickaxe...\");\n  try {\n    await craftItem(bot, \"stone_pickaxe\", 1);\n  } catch (err) {\n    bot.chat(`Failed to craft stone pickaxe: ${err.message}`);\n    return;\n  }\n\n  // Final check\n  if (bot.inventory.count(stonePickaxeItem.id) > 0) {\n    bot.chat(\"Successfully crafted a stone pickaxe.\");\n  } else {\n    bot.chat(\"Failed to craft a stone pickaxe.\");\n  }\n}", "description": "async function craftStonePickaxe(bot) {\n    // The function is about crafting a stone pickaxe using a crafting table. First check if a stone pickaxe is already in the inventory. Then verify that there are at least 3 cobblestones and 2 sticks available. Next, ensure a crafting table is placed nearby; if not, place one. Finally, craft the stone pickaxe using the crafting table.\n}"}, "mineOneCoalOre": {"code": "async function mineOneCoalOre(bot) {\n  // Check if we already have coal (coal item)\n  const coalItem = mcData.itemsByName.coal;\n  if (coalItem && bot.inventory.count(coalItem.id) > 0) {\n    bot.chat(\"Already have coal.\");\n    return;\n  }\n  // Mine 1 coal_ore\n  await mineBlock(bot, \"coal_ore\", 1);\n  bot.chat(\"Mined 1 coal ore.\");\n}", "description": "async function mineOneCoalOre(bot) {\n    // The function is about mining one coal ore block. First check if coal is already in the inventory. If coal is present, the function ends early. If not, proceed to mine one coal ore block.\n}"}, "craftFurnace": {"code": "async function craftFurnace(bot) {\n  // Step 1: Check if we already have a furnace\n  const furnaceItem = mcData.itemsByName.furnace;\n  if (bot.inventory.count(furnaceItem.id) > 0) {\n    bot.chat(\"Already have a furnace.\");\n    return;\n  }\n\n  // Step 2: Check cobblestone count\n  const cobblestoneItem = mcData.itemsByName.cobblestone;\n  let cobblestoneCount = bot.inventory.count(cobblestoneItem.id);\n  const requiredCobblestone = 8;\n  if (cobblestoneCount < requiredCobblestone) {\n    bot.chat(`Need ${requiredCobblestone} cobblestone, but only have ${cobblestoneCount}. Mining more stone...`);\n    const needed = requiredCobblestone - cobblestoneCount;\n    // Ensure we have a pickaxe\n    const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n    let hasPickaxe = false;\n    for (const name of pickaxeNames) {\n      const item = mcData.itemsByName[name];\n      if (item && bot.inventory.count(item.id) > 0) {\n        hasPickaxe = true;\n        break;\n      }\n    }\n    if (!hasPickaxe) {\n      bot.chat(\"No pickaxe to mine stone.\");\n      return;\n    }\n    // Mine stone (which drops cobblestone)\n    await mineBlock(bot, \"stone\", needed);\n    // Update count\n    cobblestoneCount = bot.inventory.count(cobblestoneItem.id);\n    bot.chat(`Now have ${cobblestoneCount} cobblestone.`);\n  }\n\n  // Step 3: Place a crafting table if not already nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    // Find a suitable position near the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Update the crafting table block\n    craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTableBlock) {\n      bot.chat(\"Failed to place crafting table.\");\n      return;\n    }\n  }\n\n  // Step 4: Craft furnace\n  bot.chat(\"Crafting furnace...\");\n  try {\n    await craftItem(bot, \"furnace\", 1);\n  } catch (err) {\n    bot.chat(`Failed to craft furnace: ${err.message}`);\n    return;\n  }\n\n  // Step 5: Verify\n  if (bot.inventory.count(furnaceItem.id) > 0) {\n    bot.chat(\"Successfully crafted a furnace.\");\n  } else {\n    bot.chat(\"Failed to craft a furnace.\");\n  }\n}", "description": "async function craftFurnace(bot) {\n    // The function is about crafting a furnace using cobblestone. First check if a furnace is already in the inventory. If not, ensure there are at least 8 cobblestones by mining more stone if needed. Then place a crafting table nearby if one is not already present. Finally, craft a furnace using the cobblestone on the crafting table.\n}"}, "mineLapisOre": {"code": "async function mineLapisOre(bot) {\n  // Check if we already have lapis lazuli\n  const lapisItem = mcData.itemsByName.lapis_lazuli;\n  if (bot.inventory.count(lapisItem.id) > 0) {\n    bot.chat(\"Already have lapis lazuli.\");\n    return;\n  }\n\n  // Ensure we have a pickaxe that can mine lapis (stone or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && bot.inventory.count(item.id) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No suitable pickaxe (stone or better) found.\");\n    return;\n  }\n\n  // Find lapis_ore nearby\n  let lapisOreBlock = bot.findBlock({\n    matching: mcData.blocksByName.lapis_ore.id,\n    maxDistance: 32\n  });\n\n  // If not found, explore\n  if (!lapisOreBlock) {\n    bot.chat(\"No lapis ore nearby, exploring...\");\n    // Random direction\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    lapisOreBlock = await exploreUntil(bot, randomDir, 60, () => {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName.lapis_ore.id,\n        maxDistance: 32\n      });\n      return block;\n    });\n    if (!lapisOreBlock) {\n      bot.chat(\"Could not find lapis ore within exploration time.\");\n      return;\n    }\n  }\n\n  // Mine the lapis ore\n  bot.chat(\"Found lapis ore, mining...\");\n  await mineBlock(bot, \"lapis_ore\", 1);\n\n  // Verify\n  if (bot.inventory.count(lapisItem.id) > 0) {\n    bot.chat(\"Successfully mined 1 lapis lazuli.\");\n  } else {\n    bot.chat(\"Failed to mine lapis lazuli.\");\n  }\n}", "description": "async function mineLapisOre(bot) {\n    // The function is about mining lapis lazuli from lapis ore. First check if lapis lazuli is already in the inventory. Then ensure a suitable pickaxe (stone or better) is available. Next, find a lapis ore block nearby; if not found, explore the environment in a random direction until one is located. Once found, mine the lapis ore block to obtain lapis lazuli. Finally, verify that lapis lazuli has been successfully collected.\n}"}, "mineIronOre": {"code": "async function mineIronOre(bot) {\n  // Check if we already have raw_iron\n  const rawIronItem = mcData.itemsByName.raw_iron;\n  if (bot.inventory.count(rawIronItem.id) > 0) {\n    bot.chat(\"Already have raw iron.\");\n    return;\n  }\n\n  // Ensure we have a pickaxe that can mine iron (stone or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && bot.inventory.count(item.id) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No suitable pickaxe (stone or better) found.\");\n    return;\n  }\n\n  // Find iron_ore nearby\n  let ironOreBlock = bot.findBlock({\n    matching: mcData.blocksByName.iron_ore.id,\n    maxDistance: 32\n  });\n\n  // If not found, explore\n  if (!ironOreBlock) {\n    bot.chat(\"No iron ore nearby, exploring...\");\n    // Random direction\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    ironOreBlock = await exploreUntil(bot, randomDir, 60, () => {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      return block;\n    });\n    if (!ironOreBlock) {\n      bot.chat(\"Could not find iron ore within exploration time.\");\n      return;\n    }\n  }\n\n  // Mine the iron ore\n  bot.chat(\"Found iron ore, mining...\");\n  await mineBlock(bot, \"iron_ore\", 1);\n\n  // Verify\n  if (bot.inventory.count(rawIronItem.id) > 0) {\n    bot.chat(\"Successfully mined 1 iron ore.\");\n  } else {\n    bot.chat(\"Failed to mine iron ore.\");\n  }\n}", "description": "async function mineIronOre(bot) {\n    // The function is about mining one iron ore using a stone or better pickaxe. First check if raw iron is already in the inventory. Next, ensure a suitable pickaxe is available. Then, find a nearby iron ore block, exploring randomly if none is found. Once located, mine the iron ore block. Finally, verify that raw iron has been successfully obtained.\n}"}, "smeltRawIron": {"code": "async function smeltRawIron(bot) {\n  // Check if we already have iron_ingot\n  const ironIngot = mcData.itemsByName.iron_ingot;\n  if (bot.inventory.count(ironIngot.id) > 0) {\n    bot.chat(\"Already have an iron ingot.\");\n    return;\n  }\n\n  // Ensure we have raw_iron\n  const rawIron = mcData.itemsByName.raw_iron;\n  if (bot.inventory.count(rawIron.id) === 0) {\n    bot.chat(\"No raw iron to smelt.\");\n    return;\n  }\n\n  // Ensure we have fuel (coal)\n  const coal = mcData.itemsByName.coal;\n  if (bot.inventory.count(coal.id) === 0) {\n    bot.chat(\"No coal for fuel.\");\n    return;\n  }\n\n  // Find a placed furnace nearby\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n\n  // If not found, place one\n  if (!furnaceBlock) {\n    bot.chat(\"Placing furnace...\");\n    // Find a suitable position near the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"furnace\", placePos);\n    // Update furnace block\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      bot.chat(\"Failed to place furnace.\");\n      return;\n    }\n  }\n\n  // Smelt raw iron using coal\n  bot.chat(\"Smelting raw iron...\");\n  try {\n    await smeltItem(bot, \"raw_iron\", \"coal\", 1);\n  } catch (err) {\n    bot.chat(`Failed to smelt: ${err.message}`);\n    return;\n  }\n\n  // Verify\n  if (bot.inventory.count(ironIngot.id) > 0) {\n    bot.chat(\"Successfully smelted 1 raw iron into an iron ingot.\");\n  } else {\n    bot.chat(\"Failed to smelt raw iron.\");\n  }\n}", "description": "async function smeltRawIron(bot) {\n    // The function is about smelting raw iron into an iron ingot using a furnace and coal as fuel. First check if an iron ingot is already present, and if not, ensure raw iron and coal are available in the inventory. Next, locate a nearby furnace or place one if none is found. Then, smelt one raw iron using coal in the furnace. Finally, verify that an iron ingot has been successfully produced.\n}"}, "mineThreeIronOre": {"code": "async function mineThreeIronOre(bot) {\n  // Check if we already have enough raw_iron\n  const rawIronItem = mcData.itemsByName.raw_iron;\n  const requiredCount = 3;\n  if (bot.inventory.count(rawIronItem.id) >= requiredCount) {\n    bot.chat(\"Already have at least 3 raw iron.\");\n    return;\n  }\n\n  // Ensure we have a stone pickaxe or better\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && bot.inventory.count(item.id) > 0) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat(\"No suitable pickaxe (stone or better) found.\");\n    return;\n  }\n  // Equip the pickaxe\n  const pickaxe = bot.inventory.findInventoryItem(pickaxeItem.id);\n  if (pickaxe) {\n    await bot.equip(pickaxe, \"hand\");\n  }\n\n  // Explore until we find at least 3 iron_ore blocks\n  bot.chat(\"Exploring to find iron ore...\");\n  const ironOreBlocks = await exploreUntil(bot, new Vec3(0, -1, 0), 60, () => {\n    const blocks = bot.findBlocks({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32,\n      count: requiredCount\n    });\n    if (blocks.length >= requiredCount) {\n      return blocks;\n    }\n    return null;\n  });\n  if (!ironOreBlocks) {\n    bot.chat(\"Could not find enough iron ore within exploration time.\");\n    return;\n  }\n\n  // Mine the iron ore\n  bot.chat(`Found iron ore, mining ${requiredCount}...`);\n  await mineBlock(bot, \"iron_ore\", requiredCount);\n\n  // Verify\n  const rawIronCount = bot.inventory.count(rawIronItem.id);\n  if (rawIronCount >= requiredCount) {\n    bot.chat(`Successfully mined ${requiredCount} iron ore. Now have ${rawIronCount} raw iron.`);\n  } else {\n    bot.chat(`Failed to mine enough iron ore. Only have ${rawIronCount} raw iron.`);\n  }\n}", "description": "async function mineThreeIronOre(bot) {\n    // The function is about mining 3 iron ore blocks using a stone pickaxe or better. First check if there are already at least 3 raw iron in the inventory. If not, ensure a suitable pickaxe is available and equip it. Then explore the environment until at least 3 iron ore blocks are found. Once found, mine exactly 3 iron ore blocks. Finally, verify the inventory contains at least 3 raw iron after mining.\n}"}, "craftIronPickaxe": {"code": "async function craftIronPickaxe(bot) {\n  // Check if we already have an iron pickaxe\n  const ironPickaxeItem = mcData.itemsByName.iron_pickaxe;\n  if (bot.inventory.count(ironPickaxeItem.id) > 0) {\n    bot.chat(\"Already have an iron pickaxe.\");\n    return;\n  }\n\n  // Ensure we have a crafting table placed nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    // Find a suitable position near the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Update the crafting table block\n    craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTableBlock) {\n      bot.chat(\"Failed to place crafting table.\");\n      return;\n    }\n  }\n\n  // Check sticks\n  const stickItem = mcData.itemsByName.stick;\n  let stickCount = bot.inventory.count(stickItem.id);\n  if (stickCount < 2) {\n    bot.chat(\"Crafting sticks...\");\n    // We need at least 2 sticks, craft from oak_planks\n    const oakPlanksItem = mcData.itemsByName.oak_planks;\n    const oakPlanksCount = bot.inventory.count(oakPlanksItem.id);\n    // Each stick recipe uses 2 planks and yields 4 sticks\n    if (oakPlanksCount < 2) {\n      bot.chat(\"Not enough oak planks to craft sticks.\");\n      // We have oak_log, we could craft more planks, but we have 3 planks already, so this shouldn't happen.\n      return;\n    }\n    try {\n      await craftItem(bot, \"stick\", 1);\n    } catch (err) {\n      bot.chat(`Failed to craft sticks: ${err.message}`);\n      return;\n    }\n    stickCount = bot.inventory.count(stickItem.id);\n    bot.chat(`Now have ${stickCount} sticks.`);\n  }\n\n  // Check iron ingots\n  const ironIngotItem = mcData.itemsByName.iron_ingot;\n  const ironIngotCount = bot.inventory.count(ironIngotItem.id);\n  if (ironIngotCount < 3) {\n    bot.chat(`Need 3 iron ingots, but only have ${ironIngotCount}.`);\n    // We have 6, so this shouldn't happen.\n    return;\n  }\n\n  // Craft iron pickaxe\n  bot.chat(\"Crafting iron pickaxe...\");\n  try {\n    await craftItem(bot, \"iron_pickaxe\", 1);\n  } catch (err) {\n    bot.chat(`Failed to craft iron pickaxe: ${err.message}`);\n    return;\n  }\n\n  // Verify\n  if (bot.inventory.count(ironPickaxeItem.id) > 0) {\n    bot.chat(\"Successfully crafted an iron pickaxe.\");\n  } else {\n    bot.chat(\"Failed to craft an iron pickaxe.\");\n  }\n}", "description": "async function craftIronPickaxe(bot) {\n    // The function is about crafting an iron pickaxe using a crafting table. First check if an iron pickaxe is already in the inventory. If not, ensure a crafting table is placed nearby. Next, verify there are enough sticks and iron ingots for the recipe. If sticks are insufficient, craft them from oak planks. Then, craft the iron pickaxe using the required materials. Finally, verify the iron pickaxe has been successfully crafted.\n}"}, "craftIronSword": {"code": "async function craftIronSword(bot) {\n  // Check if we already have an iron sword\n  const ironSwordItem = mcData.itemsByName.iron_sword;\n  if (bot.inventory.count(ironSwordItem.id) > 0) {\n    bot.chat(\"Already have an iron sword.\");\n    return;\n  }\n\n  // Ensure we have a crafting table placed nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    // Find a suitable position near the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Update the crafting table block\n    craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTableBlock) {\n      bot.chat(\"Failed to place crafting table.\");\n      return;\n    }\n  }\n\n  // Check required materials\n  const ironIngotItem = mcData.itemsByName.iron_ingot;\n  const stickItem = mcData.itemsByName.stick;\n  const ironIngotCount = bot.inventory.count(ironIngotItem.id);\n  const stickCount = bot.inventory.count(stickItem.id);\n  if (ironIngotCount < 2) {\n    bot.chat(`Need 2 iron ingots, but only have ${ironIngotCount}.`);\n    // We could smelt more, but inventory shows 3, so this shouldn't happen.\n    return;\n  }\n  if (stickCount < 1) {\n    bot.chat(`Need 1 stick, but only have ${stickCount}.`);\n    // We have 2 sticks, so this shouldn't happen.\n    return;\n  }\n\n  // Craft iron sword\n  bot.chat(\"Crafting iron sword...\");\n  try {\n    await craftItem(bot, \"iron_sword\", 1);\n  } catch (err) {\n    bot.chat(`Failed to craft iron sword: ${err.message}`);\n    return;\n  }\n\n  // Verify\n  if (bot.inventory.count(ironSwordItem.id) > 0) {\n    bot.chat(\"Successfully crafted an iron sword.\");\n  } else {\n    bot.chat(\"Failed to craft an iron sword.\");\n  }\n}", "description": "async function craftIronSword(bot) {\n    // The function is about crafting an iron sword using a crafting table. First check if an iron sword is already in the inventory. If not, ensure a crafting table is placed nearby, and if not, place one. Next, verify that there are at least 2 iron ingots and 1 stick in the inventory. Then, craft an iron sword using the crafting table. Finally, verify that the iron sword has been successfully crafted.\n}"}, "mineCopperOre": {"code": "async function mineCopperOre(bot) {\n  // Check if we already have raw_copper\n  const rawCopperItem = mcData.itemsByName.raw_copper;\n  if (rawCopperItem && bot.inventory.count(rawCopperItem.id) > 0) {\n    bot.chat(\"Already have raw copper.\");\n    return;\n  }\n\n  // Ensure we have a pickaxe that can mine copper (stone or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && bot.inventory.count(item.id) > 0) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat(\"No suitable pickaxe (stone or better) found.\");\n    return;\n  }\n  // Equip the pickaxe\n  const pickaxe = bot.inventory.findInventoryItem(pickaxeItem.id);\n  if (pickaxe) {\n    await bot.equip(pickaxe, \"hand\");\n  }\n\n  // Find copper_ore nearby\n  let copperOreBlock = bot.findBlock({\n    matching: mcData.blocksByName.copper_ore.id,\n    maxDistance: 32\n  });\n\n  // If not found, explore\n  if (!copperOreBlock) {\n    bot.chat(\"No copper ore nearby, exploring...\");\n    // Random direction\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    copperOreBlock = await exploreUntil(bot, randomDir, 60, () => {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName.copper_ore.id,\n        maxDistance: 32\n      });\n      return block;\n    });\n    if (!copperOreBlock) {\n      bot.chat(\"Could not find copper ore within exploration time.\");\n      return;\n    }\n  }\n\n  // Mine the copper ore\n  bot.chat(\"Found copper ore, mining...\");\n  await mineBlock(bot, \"copper_ore\", 1);\n\n  // Verify\n  if (rawCopperItem && bot.inventory.count(rawCopperItem.id) > 0) {\n    bot.chat(\"Successfully mined 1 copper ore.\");\n  } else {\n    bot.chat(\"Failed to mine copper ore.\");\n  }\n}", "description": "async function mineCopperOre(bot) {\n    // The function is about mining one copper ore using a stone or better pickaxe. First check if raw copper is already in the inventory. If not, ensure a suitable pickaxe is available and equip it. Then search for a copper ore block nearby. If none is found, explore the environment in a random direction until one is located. Finally, mine the copper ore block to obtain raw copper.\n}"}, "smeltFourRawCopper": {"code": "async function smeltFourRawCopper(bot) {\n  // Helper to count items\n  function countItem(name) {\n    const item = mcData.itemsByName[name];\n    return item ? bot.inventory.count(item.id) : 0;\n  }\n\n  // Step 1: Check if we already have at least 4 copper_ingot\n  const copperIngotCount = countItem(\"copper_ingot\");\n  if (copperIngotCount >= 4) {\n    bot.chat(\"Already have at least 4 copper ingots.\");\n    return;\n  }\n\n  // Step 2: Check raw_copper count\n  const rawCopperCount = countItem(\"raw_copper\");\n  const neededRawCopper = 4 - copperIngotCount;\n  if (rawCopperCount < neededRawCopper) {\n    bot.chat(`Not enough raw copper. Have ${rawCopperCount}, need ${neededRawCopper}.`);\n    return;\n  }\n\n  // Step 3: Check fuel\n  const coalCount = countItem(\"coal\");\n  const oakPlanksCount = countItem(\"oak_planks\");\n  const oakLogCount = countItem(\"oak_log\");\n  // Calculate total fuel value (simplified: coal=8, oak_planks=1.5, oak_log=1.5)\n  let fuelValue = coalCount * 8 + oakPlanksCount * 1.5 + oakLogCount * 1.5;\n  if (fuelValue < neededRawCopper) {\n    bot.chat(`Not enough fuel. Have fuel value ${fuelValue}, need ${neededRawCopper}.`);\n    return;\n  }\n\n  // Step 4: Place a furnace if not already nearby\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    bot.chat(\"Placing a furnace...\");\n    // Place furnace near the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"furnace\", placePos);\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      bot.chat(\"Failed to place furnace.\");\n      return;\n    }\n  }\n\n  // Step 5: Smelt the raw copper\n  bot.chat(`Smelting ${neededRawCopper} raw copper...`);\n  // Use coal first\n  if (coalCount > 0) {\n    await smeltItem(bot, \"raw_copper\", \"coal\", neededRawCopper);\n  } else if (oakPlanksCount > 0) {\n    await smeltItem(bot, \"raw_copper\", \"oak_planks\", neededRawCopper);\n  } else if (oakLogCount > 0) {\n    await smeltItem(bot, \"raw_copper\", \"oak_log\", neededRawCopper);\n  }\n\n  // Step 6: Verify\n  const finalCopperIngots = countItem(\"copper_ingot\");\n  if (finalCopperIngots >= 4) {\n    bot.chat(`Successfully smelted ${neededRawCopper} raw copper into ${finalCopperIngots} copper ingots.`);\n  } else {\n    bot.chat(`Only have ${finalCopperIngots} copper ingots, need 4.`);\n  }\n}", "description": "async function smeltFourRawCopper(bot) {\n    // The function is about smelting raw copper into copper ingots to obtain at least four ingots. First, it checks the current inventory for copper ingots and raw copper to determine how many raw copper need to be smelted. Next, it verifies that there is sufficient fuel available, such as coal or oak planks and logs, to support the smelting process. If a furnace is not found nearby, it places one in the environment. Then, it proceeds to smelt the required amount of raw copper using the available fuel. Finally, it confirms whether at least four copper ingots have been successfully produced.\n}"}, "mineFourCopperOre": {"code": "async function mineFourCopperOre(bot) {\n  // Helper to count items\n  function countItem(name) {\n    const item = mcData.itemsByName[name];\n    return item ? bot.inventory.count(item.id) : 0;\n  }\n\n  // Step 1: Check if we already have enough raw_copper? Actually task is to mine ore blocks.\n  // We'll just mine 4 blocks regardless.\n  const requiredOreBlocks = 4;\n\n  // Step 2: Ensure we have a pickaxe that can mine copper (stone or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = mcData.itemsByName[name];\n    if (item && countItem(name) > 0) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat(\"No suitable pickaxe (stone or better) found.\");\n    return;\n  }\n  // Equip the pickaxe\n  const pickaxe = bot.inventory.findInventoryItem(pickaxeItem.id);\n  if (pickaxe) {\n    await bot.equip(pickaxe, \"hand\");\n  }\n\n  // Step 3: Find copper_ore blocks\n  let copperOreBlocks = bot.findBlocks({\n    matching: mcData.blocksByName.copper_ore.id,\n    maxDistance: 32,\n    count: requiredOreBlocks\n  });\n\n  // If not enough, explore\n  if (copperOreBlocks.length < requiredOreBlocks) {\n    bot.chat(\"Not enough copper ore nearby, exploring...\");\n    // Random direction: prefer down because copper ore is often underground\n    const directions = [new Vec3(0, -1, 0), new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    const foundBlocks = await exploreUntil(bot, randomDir, 60, () => {\n      const blocks = bot.findBlocks({\n        matching: mcData.blocksByName.copper_ore.id,\n        maxDistance: 32,\n        count: requiredOreBlocks\n      });\n      if (blocks.length >= requiredOreBlocks) {\n        return blocks;\n      }\n      return null;\n    });\n    if (foundBlocks) {\n      copperOreBlocks = foundBlocks;\n    } else {\n      bot.chat(\"Could not find enough copper ore within exploration time.\");\n      return;\n    }\n  }\n\n  // Step 4: Mine the copper ore blocks\n  bot.chat(`Found copper ore, mining ${requiredOreBlocks} blocks...`);\n  await mineBlock(bot, \"copper_ore\", requiredOreBlocks);\n\n  // Step 5: Verify\n  const rawCopperCount = countItem(\"raw_copper\");\n  bot.chat(`Mined ${requiredOreBlocks} copper ore blocks. Now have ${rawCopperCount} raw copper.`);\n}", "description": "async function mineFourCopperOre(bot) {\n    // The function is about mining 4 copper ore blocks using a stone or better pickaxe. First, it checks the inventory for a suitable pickaxe and equips it. Then, it searches for copper ore blocks nearby. If not enough are found, it explores the environment, often heading underground, to locate the required ore blocks. Once at least 4 copper ore blocks are located, it mines them. Finally, it verifies the resulting raw copper count.\n}"}}