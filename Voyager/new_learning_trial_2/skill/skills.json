{"mineOneWoodLog": {"code": "async function mineOneWoodLog(bot) {\n  // Step 1: Explore until we find a wood log\n  bot.chat(\"Exploring to find a wood log...\");\n  const directions = [new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 0), new Vec3(-1, 0, 0)];\n  const randomIndex = Math.floor(Math.random() * directions.length);\n  const direction = directions[randomIndex];\n  const logTypes = [\"oak_log\", \"birch_log\", \"spruce_log\", \"jungle_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n  const logBlock = await exploreUntil(bot, direction, 60, () => {\n    for (const logName of logTypes) {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName[logName].id,\n        maxDistance: 32\n      });\n      if (block) return block;\n    }\n    return null;\n  });\n  if (!logBlock) {\n    bot.chat(\"Could not find a wood log within exploration time.\");\n    return;\n  }\n  // Step 2: Mine the log\n  bot.chat(\"Found a wood log. Mining...\");\n  await mineBlock(bot, mcData.blocks[logBlock.type].name, 1);\n  bot.chat(\"Successfully mined 1 wood log.\");\n}", "description": "async function mineOneWoodLog(bot) {\n    // The function is about mining one wood log from various tree types. First, explore the environment in a random direction until finding a wood log block. If a wood log is found, mine exactly one wood log block.\n}"}, "mineThreeJungleLogs": {"code": "async function mineThreeJungleLogs(bot) {\n  // Check current inventory for jungle logs\n  const jungleLogCount = bot.inventory.count(mcData.itemsByName.jungle_log.id);\n  if (jungleLogCount >= 3) {\n    bot.chat(\"Already have 3 jungle logs.\");\n    return;\n  }\n  // Explore until we find a jungle log\n  const directions = [new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 0), new Vec3(-1, 0, 0)];\n  const randomIndex = Math.floor(Math.random() * directions.length);\n  const direction = directions[randomIndex];\n  bot.chat(\"Exploring to find jungle logs...\");\n  const foundLog = await exploreUntil(bot, direction, 60, () => {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName.jungle_log.id,\n      maxDistance: 32\n    });\n    return block;\n  });\n  if (!foundLog) {\n    bot.chat(\"Could not find jungle logs within exploration time.\");\n    return;\n  }\n  // Mine 3 jungle logs\n  const needed = 3 - jungleLogCount;\n  bot.chat(`Mining ${needed} jungle logs...`);\n  await mineBlock(bot, \"jungle_log\", needed);\n  // Verify we have at least 3\n  const newCount = bot.inventory.count(mcData.itemsByName.jungle_log.id);\n  if (newCount >= 3) {\n    bot.chat(\"Successfully mined 3 jungle logs.\");\n  } else {\n    bot.chat(`Only mined ${newCount} jungle logs. Need to find more.`);\n    // Try again recursively? But we cannot use recursion due to rule. Instead, we can call the function again.\n    // However, rule says no recursive functions. We'll just report and let the caller handle.\n    // Since we are in a function, we can loop? But rule says no infinite loops.\n    // We'll just exit; the task may be retried.\n  }\n}", "description": "async function mineThreeJungleLogs(bot) {\n    // The function is about collecting three jungle logs by first checking the inventory for existing logs, then exploring in a random direction to locate jungle logs, and finally mining the required number of logs to reach a total of three.\n}"}, "craftCraftingTable": {"code": "async function craftUsingInventory(bot, name, count) {\n  const item = mcData.itemsByName[name];\n  const recipe = bot.recipesFor(item.id, null, 1, null)[0]; // null for crafting table means inventory grid\n  if (!recipe) {\n    bot.chat(`No recipe for ${name} in inventory crafting grid`);\n    return;\n  }\n  await bot.craft(recipe, count, null);\n}\n\nasync function craftCraftingTable(bot) {\n  // Step 1: Check if already have a crafting table\n  const craftingTableId = mcData.itemsByName.crafting_table.id;\n  if (bot.inventory.count(craftingTableId) >= 1) {\n    bot.chat(\"Already have a crafting table.\");\n    return;\n  }\n  // Step 2: Check planks\n  const plankNames = [\"oak_planks\", \"jungle_planks\", \"spruce_planks\", \"birch_planks\", \"acacia_planks\", \"dark_oak_planks\", \"mangrove_planks\"];\n  let totalPlanks = 0;\n  for (const name of plankNames) {\n    totalPlanks += bot.inventory.count(mcData.itemsByName[name]?.id || 0);\n  }\n  if (totalPlanks < 4) {\n    bot.chat(\"Not enough planks. Crafting planks from logs...\");\n    // Determine which log to use\n    const logNames = [\"oak_log\", \"jungle_log\", \"spruce_log\", \"birch_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n    let logId = null;\n    for (const name of logNames) {\n      const id = mcData.itemsByName[name]?.id;\n      if (id && bot.inventory.count(id) > 0) {\n        logId = id;\n        break;\n      }\n    }\n    if (!logId) {\n      bot.chat(\"No logs available to craft planks.\");\n      return;\n    }\n    // Craft planks from one log (yields 4 planks)\n    const logName = mcData.items[logId].name;\n    const plankName = logName.replace('_log', '_planks');\n    await craftUsingInventory(bot, plankName, 1); // 1 recipe yields 4 planks\n    bot.chat(`Crafted 4 ${plankName}.`);\n  }\n  // Step 3: Craft crafting table\n  bot.chat(\"Crafting a crafting table...\");\n  await craftUsingInventory(bot, \"crafting_table\", 1);\n  // Verify\n  if (bot.inventory.count(craftingTableId) >= 1) {\n    bot.chat(\"Successfully crafted a crafting table.\");\n  } else {\n    bot.chat(\"Failed to craft a crafting table.\");\n  }\n}", "description": "async function craftCraftingTable(bot) {\n    // The function is about crafting a crafting table using planks. First check if a crafting table is already in the inventory. If not, check if there are at least 4 planks available. If there are not enough planks, find any log in the inventory and craft 4 planks from it. Finally, craft a crafting table using the 4 planks.\n}"}, "craftFourJunglePlanks": {"code": "// helper function to craft using inventory grid (similar to craftUsingInventory defined earlier)\nasync function craftUsingInventory(bot, name, count) {\n  const item = mcData.itemsByName[name];\n  const recipe = bot.recipesFor(item.id, null, 1, null)[0]; // null for crafting table means inventory grid\n  if (!recipe) {\n    bot.chat(`No recipe for ${name} in inventory crafting grid`);\n    return;\n  }\n  await bot.craft(recipe, count, null);\n}\n\n// main function\n\n// main function\nasync function craftFourJunglePlanks(bot) {\n  // Step 1: Check current jungle planks count\n  const junglePlanksId = mcData.itemsByName.jungle_planks.id;\n  const currentPlanks = bot.inventory.count(junglePlanksId);\n  if (currentPlanks >= 4) {\n    bot.chat(\"Already have 4 jungle planks.\");\n    return;\n  }\n  // Step 2: Check jungle logs\n  const jungleLogId = mcData.itemsByName.jungle_log.id;\n  const logCount = bot.inventory.count(jungleLogId);\n  if (logCount < 1) {\n    bot.chat(\"Need at least 1 jungle log to craft 4 jungle planks.\");\n    // Since we have none, we need to collect jungle logs first.\n    // But according to inventory we have 3, so this shouldn't happen.\n    // However, for robustness, we can call a function to mine jungle logs.\n    // But we don't have a predefined function for that, and we cannot define recursive functions.\n    // We'll just exit and let the caller handle.\n    return;\n  }\n  // Step 3: Craft jungle planks\n  bot.chat(\"Crafting 4 jungle planks from 1 jungle log...\");\n  await craftUsingInventory(bot, \"jungle_planks\", 1);\n  // Step 4: Verify\n  const newPlanks = bot.inventory.count(junglePlanksId);\n  if (newPlanks >= 4) {\n    bot.chat(\"Successfully crafted 4 jungle planks.\");\n  } else {\n    bot.chat(`Only crafted ${newPlanks} jungle planks.`);\n  }\n}", "description": "async function craftFourJunglePlanks(bot) {\n    // The function is about crafting 4 jungle planks from jungle logs. First check if there are already at least 4 jungle planks in the inventory. If not, check if there is at least 1 jungle log available. If a jungle log is present, craft 4 jungle planks using the inventory crafting grid. Finally, verify the new count of jungle planks in the inventory.\n}"}, "craftWoodenPickaxe": {"code": "async function craftWoodenPickaxe(bot) {\n  // Step 1: Check if already have wooden pickaxe\n  const woodenPickaxeId = mcData.itemsByName.wooden_pickaxe.id;\n  if (bot.inventory.count(woodenPickaxeId) >= 1) {\n    bot.chat(\"Already have a wooden pickaxe.\");\n    return;\n  }\n\n  // Step 2: Ensure we have a crafting table nearby (already placed, but we need to be near it)\n  const craftingTable = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTable) {\n    bot.chat(\"No crafting table found. Placing one...\");\n    const craftingTablePosition = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", craftingTablePosition);\n  }\n\n  // Step 3: Check planks count\n  const plankNames = [\"oak_planks\", \"jungle_planks\", \"spruce_planks\", \"birch_planks\", \"acacia_planks\", \"dark_oak_planks\", \"mangrove_planks\"];\n  let totalPlanks = 0;\n  for (const name of plankNames) {\n    totalPlanks += bot.inventory.count(mcData.itemsByName[name]?.id || 0);\n  }\n  if (totalPlanks < 3) {\n    bot.chat(\"Need more planks. Crafting additional planks...\");\n    // Use jungle logs if available, otherwise any log\n    const logNames = [\"oak_log\", \"jungle_log\", \"spruce_log\", \"birch_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n    let logId = null;\n    for (const name of logNames) {\n      const id = mcData.itemsByName[name]?.id;\n      if (id && bot.inventory.count(id) > 0) {\n        logId = id;\n        break;\n      }\n    }\n    if (!logId) {\n      bot.chat(\"No logs available to craft planks. Need to collect wood logs first.\");\n      // Since we have jungle logs in inventory, this shouldn't happen, but for safety, we can explore and mine a log.\n      // However, we cannot call mineBlock recursively, so we'll just exit and let the caller handle.\n      return;\n    }\n    const logName = mcData.items[logId].name;\n    const plankName = logName.replace('_log', '_planks');\n    // Craft planks using the crafting table\n    await craftItem(bot, plankName, 1); // 1 recipe yields 4 planks\n    bot.chat(`Crafted 4 ${plankName}.`);\n  }\n\n  // Step 4: Check sticks\n  const stickId = mcData.itemsByName.stick.id;\n  const stickCount = bot.inventory.count(stickId);\n  if (stickCount < 2) {\n    bot.chat(\"Need more sticks. Crafting sticks...\");\n    // Craft sticks (requires 2 planks per recipe, yields 4 sticks)\n    await craftItem(bot, \"stick\", 1);\n  }\n\n  // Step 5: Craft wooden pickaxe\n  bot.chat(\"Crafting wooden pickaxe...\");\n  await craftItem(bot, \"wooden_pickaxe\", 1);\n\n  // Step 6: Verify\n  if (bot.inventory.count(woodenPickaxeId) >= 1) {\n    bot.chat(\"Successfully crafted a wooden pickaxe.\");\n  } else {\n    bot.chat(\"Failed to craft wooden pickaxe.\");\n  }\n}", "description": "async function craftWoodenPickaxe(bot) {\n    // The function is about crafting a wooden pickaxe using a crafting table. First check if a wooden pickaxe is already in the inventory. If not, ensure a crafting table is nearby and place one if needed. Then check if there are enough planks and sticks, crafting them from logs if necessary. Finally, craft the wooden pickaxe and verify the result.\n}"}, "mineCopperOre": {"code": "async function mineCopperOre(bot) {\n  // Check for a pickaxe that can mine copper ore (stone or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"diamond_pickaxe\", \"golden_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    if (bot.inventory.count(mcData.itemsByName[name]?.id || 0) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No suitable pickaxe found. Need at least stone pickaxe.\");\n    // We could craft one, but we have stone_pickaxe, so this shouldn't happen.\n    return;\n  }\n\n  // Find copper ore block nearby\n  const copperOreBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"copper_ore\"].id,\n    maxDistance: 32\n  });\n  if (copperOreBlock) {\n    bot.chat(\"Found copper ore nearby. Mining...\");\n    await mineBlock(bot, \"copper_ore\", 1);\n    bot.chat(\"Successfully mined 1 copper ore.\");\n    return;\n  }\n\n  // If not found, explore in a random direction\n  const directions = [new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1), new Vec3(0, -1, 0),\n  // down\n  new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 0), new Vec3(-1, 0, 0)];\n  const randomIndex = Math.floor(Math.random() * directions.length);\n  const direction = directions[randomIndex];\n  bot.chat(\"No copper ore nearby. Exploring...\");\n  const foundBlock = await exploreUntil(bot, direction, 60, () => {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName[\"copper_ore\"].id,\n      maxDistance: 32\n    });\n    return block;\n  });\n  if (foundBlock) {\n    bot.chat(\"Found copper ore during exploration. Mining...\");\n    await mineBlock(bot, \"copper_ore\", 1);\n    bot.chat(\"Successfully mined 1 copper ore.\");\n  } else {\n    bot.chat(\"Could not find copper ore within exploration time.\");\n  }\n}", "description": "async function mineCopperOre(bot) {\n    // The function is about mining a copper ore block using a suitable pickaxe. First check if a pickaxe of stone or better quality is available in the inventory. If a suitable pickaxe is found, search for a copper ore block nearby. If found, mine one copper ore block. If not found, explore the environment in a random direction to locate a copper ore block. Once located during exploration, mine one copper ore block.\n}"}, "smeltOneRawCopper": {"code": "async function smeltOneRawCopper(bot) {\n  // Step 1: Check for raw_copper\n  const rawCopperCount = bot.inventory.count(mcData.itemsByName.raw_copper.id);\n  if (rawCopperCount < 1) {\n    bot.chat(\"No raw_copper in inventory. Need to collect raw_copper first.\");\n    // Since we have raw_copper, this shouldn't happen, but we can explore and mine copper ore.\n    // However, we cannot call mineBlock recursively, so we'll just exit.\n    return;\n  }\n\n  // Step 2: Check for fuel (coal)\n  const fuelCount = bot.inventory.count(mcData.itemsByName.coal.id);\n  if (fuelCount < 1) {\n    bot.chat(\"No coal for fuel. Need to get fuel first.\");\n    // We have coal, so this shouldn't happen.\n    return;\n  }\n\n  // Step 3: Place furnace if not already placed nearby\n  const furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    bot.chat(\"Placing furnace...\");\n    const furnacePosition = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"furnace\", furnacePosition);\n  }\n\n  // Step 4: Smelt raw_copper using coal as fuel\n  bot.chat(\"Smelting 1 raw_copper...\");\n  await smeltItem(bot, \"raw_copper\", \"coal\", 1);\n\n  // Step 5: Verify\n  const copperIngotCount = bot.inventory.count(mcData.itemsByName.copper_ingot.id);\n  if (copperIngotCount >= 12) {\n    bot.chat(\"Successfully smelted 1 raw_copper into copper ingot.\");\n  } else {\n    bot.chat(\"Failed to smelt raw_copper.\");\n  }\n}", "description": "async function smeltOneRawCopper(bot) {\n    // The function is about smelting one raw copper into a copper ingot using a furnace and coal as fuel. First check if raw copper and coal are available in the inventory. If not, the function exits. Next, place a furnace nearby if one is not already present. Then, smelt the raw copper using coal as fuel in the furnace. Finally, verify that the smelting was successful by checking the inventory for the resulting copper ingot.\n}"}, "smeltTenRawCopper": {"code": "async function smeltTenRawCopper(bot) {\n  // Helper function to craft planks from logs using crafting table\n  async function craftPlanksFromLog(bot, logName) {\n    const plankName = logName.replace('_log', '_planks');\n    const craftingTable = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!craftingTable) {\n      bot.chat(\"Placing crafting table...\");\n      const tablePos = bot.entity.position.offset(1, 0, 0);\n      await placeItem(bot, \"crafting_table\", tablePos);\n    }\n    await craftItem(bot, plankName, 1); // 1 recipe yields 4 planks\n  }\n\n  // Step 1: Ensure we have enough fuel\n  bot.chat(\"Checking fuel...\");\n  const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n  const plankNames = [\"oak_planks\", \"jungle_planks\", \"spruce_planks\", \"birch_planks\", \"acacia_planks\", \"dark_oak_planks\", \"mangrove_planks\"];\n  let totalPlanks = 0;\n  for (const name of plankNames) {\n    totalPlanks += bot.inventory.count(mcData.itemsByName[name]?.id || 0);\n  }\n  // Calculate required fuel: need to smelt 10 items.\n  // Coal smelts 8 items each, planks smelt 1.5 each.\n  let fuelNeeded = 10;\n  let hasEnoughFuel = false;\n  if (coalCount >= 1) {\n    fuelNeeded -= 8;\n    if (fuelNeeded <= 0) hasEnoughFuel = true;\n  }\n  if (!hasEnoughFuel) {\n    // Use planks\n    const plankFuel = totalPlanks * 1.5;\n    if (plankFuel >= fuelNeeded) hasEnoughFuel = true;\n  }\n  if (!hasEnoughFuel) {\n    bot.chat(\"Not enough fuel. Getting more fuel...\");\n    // First, craft jungle_planks from jungle_log if we have one\n    const jungleLogCount = bot.inventory.count(mcData.itemsByName.jungle_log.id);\n    if (jungleLogCount > 0) {\n      bot.chat(\"Crafting jungle_planks from jungle_log...\");\n      await craftPlanksFromLog(bot, \"jungle_log\");\n    }\n    // Check again for planks\n    totalPlanks = 0;\n    for (const name of plankNames) {\n      totalPlanks += bot.inventory.count(mcData.itemsByName[name]?.id || 0);\n    }\n    // If still not enough, mine coal ore\n    fuelNeeded = 10;\n    if (coalCount >= 1) fuelNeeded -= 8;\n    if (fuelNeeded > 0) {\n      const plankFuel = totalPlanks * 1.5;\n      if (plankFuel < fuelNeeded) {\n        bot.chat(\"Need coal. Exploring for coal ore...\");\n        // Explore for coal ore\n        const directions = [new Vec3(0, -1, 0),\n        // down\n        new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1)];\n        const randomIndex = Math.floor(Math.random() * directions.length);\n        const direction = directions[randomIndex];\n        const coalBlock = await exploreUntil(bot, direction, 60, () => {\n          return bot.findBlock({\n            matching: mcData.blocksByName[\"coal_ore\"].id,\n            maxDistance: 32\n          });\n        });\n        if (coalBlock) {\n          bot.chat(\"Found coal ore. Mining...\");\n          await mineBlock(bot, \"coal_ore\", 1);\n          bot.chat(\"Mined coal ore.\");\n        } else {\n          bot.chat(\"Could not find coal ore. Using available fuel...\");\n          // We'll try with what we have, but may not smelt all 10.\n        }\n      }\n    }\n  }\n\n  // Step 2: Place furnace if not already placed\n  bot.chat(\"Checking for furnace...\");\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    bot.chat(\"Placing furnace...\");\n    const furnacePos = bot.entity.position.offset(1, 0, 0);\n    // Ensure we have a furnace in inventory (we do)\n    await placeItem(bot, \"furnace\", furnacePos);\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n  }\n\n  // Step 3: Smelt 10 raw_copper\n  bot.chat(\"Smelting 10 raw_copper...\");\n  // We'll smelt in batches using available fuel.\n  const rawCopperCount = bot.inventory.count(mcData.itemsByName.raw_copper.id);\n  const toSmelt = Math.min(rawCopperCount, 10);\n  let smelted = 0;\n  while (smelted < toSmelt) {\n    // Determine fuel to use: prefer coal, then planks\n    let fuelName = null;\n    if (bot.inventory.count(mcData.itemsByName.coal.id) > 0) {\n      fuelName = \"coal\";\n    } else {\n      // Find any planks\n      for (const name of plankNames) {\n        if (bot.inventory.count(mcData.itemsByName[name]?.id || 0) > 0) {\n          fuelName = name;\n          break;\n        }\n      }\n    }\n    if (!fuelName) {\n      bot.chat(\"No fuel left. Cannot smelt more.\");\n      break;\n    }\n    // Smelt one at a time to manage fuel usage\n    await smeltItem(bot, \"raw_copper\", fuelName, 1);\n    smelted++;\n    bot.chat(`Smelted ${smelted}/${toSmelt} raw_copper.`);\n  }\n\n  // Step 4: Verify\n  const copperIngotCount = bot.inventory.count(mcData.itemsByName.copper_ingot.id);\n  bot.chat(`Smelting complete. Total copper ingots: ${copperIngotCount}`);\n  if (copperIngotCount >= 11) {\n    // we started with 1, so 10 more\n    bot.chat(\"Successfully smelted 10 raw copper.\");\n  } else {\n    bot.chat(`Only smelted ${copperIngotCount - 1} raw copper. Need more fuel.`);\n  }\n}", "description": "async function smeltTenRawCopper(bot) {\n    // The function is about smelting 10 raw copper into copper ingots using a furnace. First, it checks if there is enough fuel, such as coal or planks, and gathers more if needed. Then, it ensures a furnace is placed nearby. Next, it smelts the raw copper in batches, prioritizing coal as fuel before using planks. Finally, it verifies the number of copper ingots produced and reports the outcome.\n}"}, "craftStonePickaxe": {"code": "async function craftStonePickaxe(bot) {\n  // Step 1: Check if we have enough sticks (2)\n  const stickId = mcData.itemsByName.stick.id;\n  const stickCount = bot.inventory.count(stickId);\n  if (stickCount < 2) {\n    bot.chat(\"Not enough sticks. Crafting sticks from planks...\");\n    // Check for planks\n    const plankNames = [\"oak_planks\", \"jungle_planks\", \"spruce_planks\", \"birch_planks\", \"acacia_planks\", \"dark_oak_planks\", \"mangrove_planks\"];\n    let plankId = null;\n    for (const name of plankNames) {\n      const id = mcData.itemsByName[name]?.id;\n      if (id && bot.inventory.count(id) >= 2) {\n        plankId = id;\n        break;\n      }\n    }\n    if (!plankId) {\n      bot.chat(\"Not enough planks to craft sticks. Need to collect wood logs.\");\n      // Since we have jungle_planks, this shouldn't happen, but for safety, we can explore and mine a log.\n      // However, we cannot call mineBlock recursively, so we'll just exit.\n      return;\n    }\n    // Craft sticks (2 planks -> 4 sticks)\n    const plankName = mcData.items[plankId].name;\n    await craftItem(bot, \"stick\", 1); // craftItem uses crafting table, but we haven't placed one yet.\n    // However, craftItem requires a crafting table, so we need to place one first.\n    // We'll place a crafting table before crafting sticks.\n  }\n\n  // Step 2: Place a crafting table if not already placed nearby\n  const craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    bot.chat(\"Placing crafting table...\");\n    const craftingTablePosition = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"crafting_table\", craftingTablePosition);\n  }\n\n  // Step 3: Now craft sticks if we still need them (re-check after placing table)\n  if (stickCount < 2) {\n    bot.chat(\"Crafting sticks...\");\n    await craftItem(bot, \"stick\", 1);\n  }\n\n  // Step 4: Check cobblestone (need 3)\n  const cobblestoneId = mcData.itemsByName.cobblestone.id;\n  const cobblestoneCount = bot.inventory.count(cobblestoneId);\n  if (cobblestoneCount < 3) {\n    bot.chat(\"Not enough cobblestone. Need to mine stone.\");\n    // Mine stone to get cobblestone\n    await mineBlock(bot, \"stone\", 3 - cobblestoneCount);\n  }\n\n  // Step 5: Craft stone pickaxe\n  bot.chat(\"Crafting stone pickaxe...\");\n  await craftItem(bot, \"stone_pickaxe\", 1);\n\n  // Step 6: Verify\n  const stonePickaxeId = mcData.itemsByName.stone_pickaxe.id;\n  if (bot.inventory.count(stonePickaxeId) >= 1) {\n    bot.chat(\"Successfully crafted a stone pickaxe.\");\n  } else {\n    bot.chat(\"Failed to craft stone pickaxe.\");\n  }\n}", "description": "async function craftStonePickaxe(bot) {\n    // The function is about crafting a stone pickaxe by gathering necessary materials and using a crafting table. First, check if there are enough sticks and cobblestones in the inventory. If not, craft sticks from planks and mine stone to obtain cobblestone. Next, place a crafting table if one is not nearby. Then, use the crafting table to craft a stone pickaxe. Finally, verify that the stone pickaxe has been successfully crafted.\n}"}, "mineCoalOre": {"code": "async function mineCoalOre(bot) {\n  // Check for a pickaxe that can mine coal ore (wooden or better)\n  const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"diamond_pickaxe\", \"golden_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    if (bot.inventory.count(mcData.itemsByName[name]?.id || 0) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No suitable pickaxe found. Need at least wooden pickaxe.\");\n    // Since we have wooden_pickaxe and stone_pickaxe, this shouldn't happen.\n    return;\n  }\n\n  // Check if coal ore is nearby\n  const coalOreBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"coal_ore\"].id,\n    maxDistance: 32\n  });\n  if (coalOreBlock) {\n    bot.chat(\"Found coal ore nearby. Mining...\");\n    await mineBlock(bot, \"coal_ore\", 1);\n    bot.chat(\"Successfully mined 1 coal ore.\");\n    // Verify\n    const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n    if (coalCount > 0) {\n      bot.chat(`Now have ${coalCount} coal.`);\n    } else {\n      bot.chat(\"Failed to collect coal.\");\n    }\n    return;\n  }\n\n  // If not found, explore in a random direction\n  const directions = [new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1), new Vec3(0, -1, 0),\n  // down\n  new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 0), new Vec3(-1, 0, 0)];\n  const randomIndex = Math.floor(Math.random() * directions.length);\n  const direction = directions[randomIndex];\n  bot.chat(\"No coal ore nearby. Exploring...\");\n  const foundBlock = await exploreUntil(bot, direction, 60, () => {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName[\"coal_ore\"].id,\n      maxDistance: 32\n    });\n    return block;\n  });\n  if (foundBlock) {\n    bot.chat(\"Found coal ore during exploration. Mining...\");\n    await mineBlock(bot, \"coal_ore\", 1);\n    bot.chat(\"Successfully mined 1 coal ore.\");\n    const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n    if (coalCount > 0) {\n      bot.chat(`Now have ${coalCount} coal.`);\n    } else {\n      bot.chat(\"Failed to collect coal.\");\n    }\n  } else {\n    bot.chat(\"Could not find coal ore within exploration time.\");\n  }\n}", "description": "async function mineCoalOre(bot) {\n    // The function is about mining a coal ore using a suitable pickaxe. First check if any pickaxe is available in the inventory. If a pickaxe is available, search for a nearby coal ore block. If found, mine one coal ore block. If not found, explore in a random direction to locate a coal ore block. Once found during exploration, mine one coal ore block. Finally, verify the coal count in the inventory.\n}"}, "mineOneCoalOre": {"code": "async function mineOneCoalOre(bot) {\n  // Check for a pickaxe that can mine coal ore (wooden or better)\n  const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"diamond_pickaxe\", \"golden_pickaxe\", \"netherite_pickaxe\"];\n  let hasPickaxe = false;\n  for (const name of pickaxeNames) {\n    if (bot.inventory.count(mcData.itemsByName[name]?.id || 0) > 0) {\n      hasPickaxe = true;\n      break;\n    }\n  }\n  if (!hasPickaxe) {\n    bot.chat(\"No suitable pickaxe found. Need at least wooden pickaxe.\");\n    return;\n  }\n\n  // Check if coal ore is nearby\n  const coalOreBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"coal_ore\"].id,\n    maxDistance: 32\n  });\n  if (coalOreBlock) {\n    bot.chat(\"Found coal ore nearby. Mining...\");\n    await mineBlock(bot, \"coal_ore\", 1);\n    bot.chat(\"Successfully mined 1 coal ore.\");\n    // Verify\n    const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n    if (coalCount > 0) {\n      bot.chat(`Now have ${coalCount} coal.`);\n    } else {\n      bot.chat(\"Failed to collect coal.\");\n    }\n    return;\n  }\n\n  // If not found, explore in a random direction\n  const directions = [new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1), new Vec3(0, -1, 0),\n  // down\n  new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 0), new Vec3(-1, 0, 0)];\n  const randomIndex = Math.floor(Math.random() * directions.length);\n  const direction = directions[randomIndex];\n  bot.chat(\"No coal ore nearby. Exploring...\");\n  const foundBlock = await exploreUntil(bot, direction, 60, () => {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName[\"coal_ore\"].id,\n      maxDistance: 32\n    });\n    return block;\n  });\n  if (foundBlock) {\n    bot.chat(\"Found coal ore during exploration. Mining...\");\n    await mineBlock(bot, \"coal_ore\", 1);\n    bot.chat(\"Successfully mined 1 coal ore.\");\n    const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n    if (coalCount > 0) {\n      bot.chat(`Now have ${coalCount} coal.`);\n    } else {\n      bot.chat(\"Failed to collect coal.\");\n    }\n  } else {\n    bot.chat(\"Could not find coal ore within exploration time.\");\n  }\n}", "description": "async function mineOneCoalOre(bot) {\n    // The function is about mining one coal ore using a suitable pickaxe. First check if any pickaxe is available in the inventory. If a pickaxe is available, look for a nearby coal ore block. If found, mine one coal ore block and verify the coal count. If not found nearby, explore in a random direction to find a coal ore block. If found during exploration, mine one coal ore block and verify the coal count.\n}"}, "smeltOneCopperOre": {"code": "async function smeltOneCopperOre(bot) {\n  // Step 1: Check for copper ore in inventory\n  const copperOreCount = bot.inventory.count(mcData.itemsByName.copper_ore.id);\n  if (copperOreCount >= 1) {\n    bot.chat(\"Already have copper ore.\");\n  } else {\n    bot.chat(\"No copper ore. Need to mine copper ore.\");\n    // Step 2: Ensure we have a suitable pickaxe (stone or better)\n    const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"diamond_pickaxe\", \"golden_pickaxe\", \"netherite_pickaxe\"];\n    let hasPickaxe = false;\n    for (const name of pickaxeNames) {\n      if (bot.inventory.count(mcData.itemsByName[name]?.id || 0) > 0) {\n        hasPickaxe = true;\n        // Equip it if not already equipped\n        const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n        if (item) {\n          await bot.equip(item, \"hand\");\n        }\n        break;\n      }\n    }\n    if (!hasPickaxe) {\n      bot.chat(\"No suitable pickaxe. Cannot mine copper ore.\");\n      return;\n    }\n    // Step 3: Find copper ore nearby or explore\n    let copperOreBlock = bot.findBlock({\n      matching: mcData.blocksByName[\"copper_ore\"].id,\n      maxDistance: 32\n    });\n    if (!copperOreBlock) {\n      bot.chat(\"No copper ore nearby. Exploring...\");\n      // Random direction: down, or horizontal\n      const directions = [new Vec3(0, -1, 0),\n      // down\n      new Vec3(1, 0, 1), new Vec3(-1, 0, 1), new Vec3(1, 0, -1), new Vec3(-1, 0, -1)];\n      const randomIndex = Math.floor(Math.random() * directions.length);\n      const direction = directions[randomIndex];\n      copperOreBlock = await exploreUntil(bot, direction, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName[\"copper_ore\"].id,\n          maxDistance: 32\n        });\n      });\n    }\n    if (copperOreBlock) {\n      bot.chat(\"Found copper ore. Mining...\");\n      await mineBlock(bot, \"copper_ore\", 1);\n      bot.chat(\"Mined 1 copper ore.\");\n    } else {\n      bot.chat(\"Could not find copper ore.\");\n      return;\n    }\n  }\n\n  // Step 4: Check for furnace nearby or place one\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    bot.chat(\"Placing furnace...\");\n    // Place furnace near player\n    const furnacePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, \"furnace\", furnacePos);\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n  }\n\n  // Step 5: Check for fuel (coal)\n  const coalCount = bot.inventory.count(mcData.itemsByName.coal.id);\n  if (coalCount < 1) {\n    bot.chat(\"No coal for fuel. Need to get coal.\");\n    // We have coal, but just in case, we can mine coal ore if needed.\n    // Since we have coal, this shouldn't happen.\n    return;\n  }\n\n  // Step 6: Smelt copper ore\n  bot.chat(\"Smelting copper ore...\");\n  await smeltItem(bot, \"copper_ore\", \"coal\", 1);\n\n  // Step 7: Verify\n  const copperIngotCount = bot.inventory.count(mcData.itemsByName.copper_ingot.id);\n  bot.chat(`Smelting complete. Total copper ingots: ${copperIngotCount}`);\n  if (copperIngotCount >= 13) {\n    bot.chat(\"Successfully smelted 1 copper ore.\");\n  } else {\n    bot.chat(\"Failed to smelt copper ore.\");\n  }\n}", "description": "async function smeltOneCopperOre(bot) {\n    // The function is about smelting one copper ore into a copper ingot using a furnace. First check if copper ore is in the inventory; if not, mine one copper ore using a suitable pickaxe. Next, ensure a furnace is available nearby; if not, place one. Then verify that coal is available for fuel. Finally, smelt the copper ore using the furnace and coal.\n}"}}